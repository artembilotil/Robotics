/**
 * TETRIS GAME - SOLID REFACTORED
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * ЦЕ ГОЛОВНИЙ ФАЙЛ ПРОГРАМИ - ТОЧКА ВХОДУ
 * 
 * АРХІТЕКТУРА ПРОЕКТУ (як будівля з поверхів):
 * ┌─────────────────────────────────────────┐
 * │  main.cpp - ВХІД (1-й поверх)          │  ← Тут все починається
 * │  Ініціалізація + головний цикл         │
 * └────────────┬────────────────────────────┘
 *              │ скоординував
 * ┌────────────▼────────────────────────────┐
 * │  GameEngine.h - ЦЕНТР (2-й поверх)     │  ← Командний центр гри
 * │  Керує всіма компонентами              │
 * └────────────┬────────────────────────────┘
 *              │ використовує
 *    ┌─────────┼─────────┬──────────────┐
 *    │         │         │              │
 * ┌──▼──┐  ┌──▼──┐  ┌──▼──┐  ┌──▼──────┐
 * │Field│  │Block│  │Input│  │ Render   │
 * │ОТ   │  │CTRL │  │Handler      │
 * │(по) │  │(рух)│  │(кнопки)   │(вивід)  │
 * └─────┘  └─────┘  └─────┘  └──────────┘
 *
 * ПРИНЦИПИ SOLID (5 правил доброго коду):
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * S - Single Responsibility (Одна відповідальність)
 *     → Кожен клас робить ОДНЕ, але робить це добре
 *     → Приклад: GameField тільки керує полем, не малює його
 * 
 * O - Open/Closed (Відкрито для розширення, закрито для змін)
 *     → Легко додавати нові фічі без зміни старого коду
 *     → Приклад: можна додати новий тип блоку без змін GameEngine
 * 
 * L - Liskov Substitution (Заміна без проблем)
 *     → Підклас можна використовувати замість батька
 *     → Приклад: будь-який Block можна використовувати як Block
 * 
 * I - Interface Segregation (Маленькі інтерфейси)
 *     → Не змушуйте клас реалізувати непотрібні методи
 *     → Приклад: InputHandler не має методів для малювання
 * 
 * D - Dependency Inversion (Залежіть від ідей, не від реалізації)
 *     → Передавайте залежності як параметри конструктора
 *     → Приклад: GameEngine отримує ledControl, а не створює його
 */

#include <Arduino.h>
#include <LedControl.h>
#include "core/GameEngine.h"

// ═══════════════════════════════════════════════════════════════════════════
// КОНФІГУРАЦІЯ АПАРАТУРИ (піни Arduino)
// ═══════════════════════════════════════════════════════════════════════════
// Це місця, де підключено фізичні пристрої до Arduino

// LED матриця (MAX7219) піни
#define DIN_PIN 6      // Data IN (передача даних)
#define CLK_PIN 5      // Clock (синхронізація)
#define CS_PIN 3       // Chip Select (вибір мікросхеми)
#define NUM_MODULES 4  // Кількість модулів 8x8 LED (4 модулі = 32 пікселя висоти)

// Джойстик піни
#define VRx_PIN A0     // Вісь X (вліво-вправо)
#define VRy_PIN A1     // Вісь Y (вгору-вниз)
#define SW_PIN 2       // Кнопка (поворот блока)

// Параметри гри
const int SCREEN_WIDTH = 8;      // Ширина екрану: 8 пікселів
const int SCREEN_HEIGHT = 32;    // Висота екрану: 8 * 4 модулей = 32 пікселя

// ═══════════════════════════════════════════════════════════════════════════
// ГЛОБАЛЬНІ ОБЄКТИ (СИНГЛТОНИ - один на весь проект)
// ═══════════════════════════════════════════════════════════════════════════
// Ці обєкти існують від початку та до кінця програми

// LedControl - обєкт для керування LED матрицею
// (передаємо йому піни, щоб він знав як комунікувати)
LedControl ledControl(DIN_PIN, CLK_PIN, CS_PIN, NUM_MODULES);

// JoystickInput - обєкт для читання джойстика (палиці керування)
JoystickInput joystick(VRx_PIN, VRy_PIN);

// ButtonInput - обєкт для читання кнопки (повороту)
ButtonInput rotateButton(SW_PIN);

// GameEngine - головний клас гри (FACADE паттерн)
// Це центр командування - він керує всім!
GameEngine *gameEngine = nullptr;

// ═══════════════════════════════════════════════════════════════════════════
// ФУНКЦІЇ ARDUINO
// ═══════════════════════════════════════════════════════════════════════════

/**
 * setup() - ЗАПУСК ПРОГРАМИ
 * 
 * Виконується ОДИН РАЗ на початку
 * Тут ми ініціалізуємо (готуємо до роботи) всі компоненти
 */
void setup() {
    // Запустити послідовний монітор (для DEBUG інформації)
    Serial.begin(9600);
    
    // Ініціалізувати генератор випадкових чисел
    // (потрібен для випадкового вибору фігур)
    randomSeed(analogRead(0));
    
    // СТВОРИТИ ЦЕНТР КОМАНДУВАННЯ ГОРИ
    // Передаємо йому:
    // - розміри екрану (8x32)
    // - LED матрицю для вивод)
    // - джойстик для введення
    // - кнопку для повороту
    gameEngine = new GameEngine(
        SCREEN_WIDTH,
        SCREEN_HEIGHT,
        NUM_MODULES,
        ledControl,
        joystick,
        rotateButton
    );
    
    // Розпочати нову гру
    gameEngine->init();
    
    // Надіслати повідомлення на комп'ютер (DEBUG)
    Serial.println("Game Started!");
}


/**
 * loop() - ГОЛОВНИЙ ЦИ ПРОГРАМИ
 * 
 * Виконується ПОСТІЙНО (тисячі разів на секунду)
 * Це як серцебиття програми - без цього гра не рухається
 */
void loop() {
    // КРОК 1: Оновити один кадр гри
    // (обробити введення, перемістити блок, перевірити колізії)
    gameEngine->update();
    
    // КРОК 2: Перевірити чи гра закінчена
    if (gameEngine->getGameOverStatus()) {
        // Вивести на екран результат гри
        Serial.print("GAME OVER! Score: ");
        Serial.println(gameEngine->getScore());
        
        // Чекати поки гравець натисне кнопку для нової гри
        // У цьому часі показуємо "PLAY" з миготінням
        gameEngine->waitForRestart();
    }
}