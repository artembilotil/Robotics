#pragma once

/**
 * МОДУЛЬ: GameEngine.h (ЦЕНТР КОМАНДУВАННЯ ГОРИ)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * ВІДПОВІДАЛЬНІСТЬ: Координація всіх компонентів гри
 * 
 * Це головний клас - він як диригент оркестру!
 * Він знає як:
 *   1. Рухати блоки
 *   2. Перевіряти колізії (удари)
 *   3.清усувати рядки
 *   4. Рахувати очки
 *   5. Малювати все на екран
 * 
 * ПАТТЕРН: FACADE (Фасад)
 * ═══════════════════════════════════════════════════════════════════════════
 * Фасад - це один вхід до складної системи.
 * Замість головної програми знати про 10 різних класів,
 * вона просто комунікує з одним - GameEngine!
 * 
 * Як в готелі - ви не говорите з кожним працівником окремо,
 * ви скажете консьєржу, а він все влаштує!
 * 
 * ПРИНЦИП SOLID: Dependency Inversion (Залежність від Абстракцій)
 * ═══════════════════════════════════════════════════════════════════════════
 * GameEngine отримує все як параметри конструктора:
 *   - ledControl → для малювання
 *   - joystick → для введення
 *   - rotateBtn → для кнопок
 * 
 * Це означає:
 *   ✓ Легко замінити LED на LCD (просто передай новий obект)
 *   ✓ Легко тестувати (можна передати fake obекти)
 *   ✓ Низька залежність від конкретної реалізації
 */

#include "Block.h"
#include "GameField.h"
#include "BlockFactory.h"
#include "BlockController.h"
#include "GameRenderer.h"
#include "GameTimer.h"
#include "InputHandler.h"
#include "ShapeData.h"

// ═══════════════════════════════════════════════════════════════════════════
// КЛАС GAMEENGINE - ЦЕНТР КОМАНДУВАННЯ
// ═══════════════════════════════════════════════════════════════════════════

class GameEngine {
private:
    // ────────────────────────────────────────────────────────────────────────
    // КОМПОНЕНТИ ГРИ (приватні - видно тільки всередині класу)
    // ────────────────────────────────────────────────────────────────────────
    // Це як внутрішні органи - ніхто не повинен до них доступатися напряму!
    
    GameField gameField;           // Ігрове поле (буфер пікселів)
    Block currentBlock;            // Поточний падаючий блок
    ShapeProvider shapeProvider;   // Постачальник фігур (всі можливі форми)
    BlockFactory blockFactory;     // Фабрика - робить нові блоки
    BlockController blockController; // Контролер - керує рухом блока
    GameRenderer renderer;         // Малюватель - вивід на екран
    GameTimerManager timers;       // Менеджер часу - синхронізація FPS
    
    // Вхідні пристрої (ПОСИЛАННЯ - не копіюємо, а посилаємось)
    // Посилання = отримуємо від основної програми, не створюємо самі
    JoystickInput &joystick;     // Джойстик для руху (вліво-вправо)
    ButtonInput &rotateBtn;       // Кнопка для повороту
    
    // ────────────────────────────────────────────────────────────────────────
    // СТАН ГРИ (приватні змінні)
    // ────────────────────────────────────────────────────────────────────────
    
    bool isGameOver;              // Чи закінчена гра?
    int score;                    // Поточні очки
    int linesCleared;             // Кількість очищених рядків

public:
    // ────────────────────────────────────────────────────────────────────────
    // КОНСТРУКТОР (ініціалізатор класу)
    // ────────────────────────────────────────────────────────────────────────
    // Це функція, яка "розбудовує" obект класу
    // Вона викликається один раз при створенні obекту
    // Синтаксис: GameEngine engine(w, h, m, led, joy, btn);
    
    GameEngine(int screenWidth, int screenHeight, int modules,
        LedControl &ledControl,JoystickInput &joy,ButtonInput &btn)
        // ИНИЦИАЛИЗАТОРСЬКИЙ СПИСОК (ініціалізація членів класу)
        // Це як конструюємо компоненти
        : gameField(screenWidth, screenHeight),        // Створюємо поле
          currentBlock(nullptr, 0, 0, 0, 'O'),         // Стартовий блок
          blockFactory(&shapeProvider, screenWidth),   // Фабрика знає про фігури
          blockController(&currentBlock, &gameField, &shapeProvider), // Контроллер
          renderer(ledControl, modules, screenWidth, screenHeight),   // Малюватель
          joystick(joy),                               // Посилання на джойстик
          rotateBtn(btn),                              // Посилання на кнопку
          isGameOver(false),                           // Гра не закінчена
          score(0),                                    // Очки = 0
          linesCleared(0) {}                           // Рядків = 0

    // ────────────────────────────────────────────────────────────────────────
    // ПУБЛІЧНІ МЕТОДИ (доступні ззовні класу)
    // ────────────────────────────────────────────────────────────────────────

    /**
     * init() - РОЗПОЧАТИ НОВУ ГРУ
     * 
     * Очищує все старе та готує гру до початку
     * Викликається один раз на старте або при рестарті
     */
    void init() {
        gameField.clear();              // Очистити поле від старих блоків
        renderer.clear();               // Вимкнути всі LED
        spawnNewBlock();                // Створити перший блок
        timers.reset();                 // Скинути таймери
        isGameOver = false;             // Гра не закінчена
        score = 0;                      // Очки = 0
        linesCleared = 0;               // Рядків = 0
    }

    /**
     * spawnNewBlock() - З'ЯВИТИ НОВИЙ БЛОК
     * 
     * Повідомляє: true = успішно, false = GAME OVER!
     * (Якщо новий блок одразу зіткнувся - гра закінчена)
     */
    bool spawnNewBlock() {
        // Попросити фабрику створити випадковий блок
        currentBlock = blockFactory.createRandomBlock();
        
        // Перевірити чи він одразу в колізії (вже є блоки у стартовій позиції)
        if (gameField.checkCollision(currentBlock, currentBlock.x, currentBlock.y)) {
            isGameOver = true;  // Гра закінчена!
            return false;       // Помилка - не змогли спавнити
        }
        return true;            // Успішно спавнили
    }

    /**
     * update() - ОНОВИТИ ОДИН КАДР ГРИ
     * 
     * Це як один удар серця - рухаємо блоки, читаємо кнопки, малюємо
     * Викликається сотні разів на секунду у loop()
     */
    void update() {
        // Якщо гра вже закінчена - нічого не робимо
        if (isGameOver) return;

        // ─────────────────────────────────────────────────────────────────────
        // ОБРОБИТИ ГОРИЗОНТАЛЬНИЙ РУХ (вліво-вправо)
        // ─────────────────────────────────────────────────────────────────────
        
        // Перевірити чи прийшов час для рухомо блока
        // (не рухаємо кожен кадр, а з деякою затримкою для плавності)
        if (timers.moveTimer.isReady()) {
            // Прочитати позицію джойстика
            int horizontalInput = joystick.getHorizontalInput();
            
            // Якщо палиця відхилена вправо
            if (horizontalInput > 0) {
                blockController.moveRight();
            } 
            // Якщо палиця відхилена вліво
            else if (horizontalInput < 0) {
                blockController.moveLeft();
            }
        }

        // ─────────────────────────────────────────────────────────────────────
        // ОБРОБИТИ ПОВОРОТ (кнопка)
        // ─────────────────────────────────────────────────────────────────────
        
        // Якщо гравець натиснув кнопку повороту
        if (rotateBtn.wasPressed()) {
            blockController.rotate();
        }

        // ─────────────────────────────────────────────────────────────────────
        // ОБРОБИТИ ПАДІННЯ (вниз)
        // ─────────────────────────────────────────────────────────────────────
        
        // Отримати усунення швидкості від джойстика
        // (якщо палиця донизу - блок падає швидше)
        int speedBoost = joystick.getDropSpeedBoost();
        
        // Обчислити інтервал падіння в мс
        // (700 мс - базова швидкість, мінус усунення)
        unsigned long currentDropInterval = 700 - speedBoost;
        timers.dropTimer.setInterval(currentDropInterval);

        // Якщо прийшов час для падіння на один ряд
        if (timers.dropTimer.isReady()) {
            // Спробувати опустити блок на один ряд
            // dropOneStep() повертає false якщо блок досяг дна
            if (!blockController.dropOneStep()) {
                // ═════════════════════════════════════════════════════════════
                // БЛОК ПРИЗЕМЛИВСЯ!
                // ═════════════════════════════════════════════════════════════
                
                // Додати блок до поля (зафіксувати його)
                gameField.addBlock(currentBlock);
                
                // Перевірити чи утворилися повні рядки
                int cleared = gameField.clearFullRows();
                linesCleared += cleared;
                
                // Додати очки: кожний рядок = 100 очків
                score += cleared * 100;

                // Спробувати спавнити новий блок
                if (!spawnNewBlock()) {
                    // ═══════════════════════════════════════════════════════
                    // GAME OVER! Не змогли спавнити новий блок
                    // ═══════════════════════════════════════════════════════
                    
                    // Запустити красиву анімацію "Game Over"
                    renderer.playGameOverAnimation();
                }
            }
        }

        // ─────────────────────────────────────────────────────────────────────
        // ОНОВИТИ ЕКРАН (малювання)
        // ─────────────────────────────────────────────────────────────────────
        
        // Якщо прийшов час для оновлення екрану (60 FPS)
        if (timers.refreshTimer.isReady()) {
            // Попросити малюватель оновити дисплей
            renderer.render(gameField, currentBlock);
        }
    }

    /**
     * waitForRestart() - ЧЕКАТИ НАТИСКУ КНОПКИ ДЛЯ РЕСТАРТУ
     * 
     * Показує "PLAY" з миготінням
     * Блокує програму поки не натиснешь кнопку
     */
    void waitForRestart() {
        // Цикл: показуємо - ховаємо - показуємо... поки не натиснешь
        while (!rotateBtn.wasPressed()) {
            renderer.displayPlayText();  // Показати "PLAY"
            delay(600);                  // Чекати 600 мс
            
            renderer.clear();            // Вимкнути всі LED
            delay(400);                  // Чекати 400 мс
        }
        
        // Натиснули кнопку - розпочинаємо нову гру!
        init();
    }

    // ────────────────────────────────────────────────────────────────────────
    // GETTER МЕТОДИ (отримувачі інформації)
    // ────────────────────────────────────────────────────────────────────────
    // Це методи для отримання приватної інформації класу
    // Вони "читаються" і не змінюють stan гри (const - обіцянка не змінювати)

    /**
     * getGameOverStatus() - ЧИ ЗАКІНЧЕНА ГРА?
     * Повідомляє: true = гра закінчена, false = гра ще йде
     */
    bool getGameOverStatus() const { return isGameOver; }
    
    /**
     * getScore() - СКІЛЬКИ ОЧКІВ?
     * Повідомляє поточні очки гравця
     */
    int getScore() const { return score; }
    
    /**
     * getLinesCleared() - СКІЛЬКИ РЯДКІВ ОЧИЩЕНО?
     * Повідомляє кількість完全очищених рядків
     */
    int getLinesCleared() const { return linesCleared; }
};
