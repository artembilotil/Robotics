#pragma once

/**
 * МОДУЛЬ: GameField.h (ІГРОВЕ ПОЛЕ)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * ВІДПОВІДАЛЬНІСТЬ: Управління ігровим полем (буфер пікселів)
 * 
 * Це як "матриця" - 2D сітка, де зберігаємо інформацію про блоки
 * Кожна клітина має два стани: порожня (0) або зайнята (1)
 * 
 * Поле робить:
 *   ✓ Зберігає всі "приземлені" блоки
 *   ✓ Перевіряє колізії (удари)
 *   ✓ Очищує повні рядки
 *   ✓ Дає доступ до даних для малювання
 * 
 * ПРИНЦИП SOLID: Single Responsibility (Одна Відповідальність)
 * ═══════════════════════════════════════════════════════════════════════════
 * GameField ТІЛЬКИ працює з полем!
 * Рух блока - не його справа (робить BlockController)
 * Малювання - не його справа (робить GameRenderer)
 * 
 * ВНУТРІШНЯ СТРУКТУРА ПОЛЯ:
 * ═══════════════════════════════════════════════════════════════════════════
 * field[0]  = 0b10101010 ← верхній рядок екрану
 * field[1]  = 0b01010101
 * field[2]  = 0b00000000
 * ...
 * field[31] = 0b11111110 ← нижній рядок екрану
 * 
 * Кожен uint8_t (1 байт) = один рядок (8 пікселів шириною)
 * Кожен біт = один піксель (0=порожньо, 1=зайнято)
 * 
 * АНАЛОГІЯ: це як дошка для гри в хрестики-нулики,
 * але замість 3x3 клітинок у нас 8x32
 */

#include "Block.h"

/**
 * КЛАС GAMEFIELD - БУФЕР ІГРОВОГО ПОЛЯ
 */
class GameField {
private:
    // ────────────────────────────────────────────────────────────────────────
    // ПРИВАТНІ ЧЛЕНИ КЛАСУ (видно тільки всередині)
    // ────────────────────────────────────────────────────────────────────────
    
    const int width;        // ШИРИНА поля (завжди 8 пікселів)
    const int height;       // ВИСОТА поля (завжди 32 пікселя)
    
    uint8_t *field;         // ДИНАМІЧНИЙ МАСИВ для зберігання поля
                            // field[y] = 1 рядок з 8 пікселів
                            // Кожен біт = один піксель (0 або 1)
                            // 
                            // Чому uint8_t?
                            // - 1 байт = 8 біт = 8 пікселів ідеально!
                            // - Економно в пам'яті
                            // - Легко скопіювати в LED матрицю

public:
    // ────────────────────────────────────────────────────────────────────────
    // КОНСТРУКТОР - Ініціалізація поля
    // ────────────────────────────────────────────────────────────────────────
    
    /**
     * GameField(int w, int h) - СТВОРИТИ ПОЛЕ
     * 
     * Параметри:
     *   w = ширина (зазвичай 8)
     *   h = висота (зазвичай 32)
     * 
     * Інціалізаторський список - встановлює const члени
     * (const члени можна встановити тільки у конструкторі!)
     */
    GameField(int w, int h) : width(w), height(h) {
        // Створити динамічний масив з height рядків
        field = new uint8_t[height];
        
        // Очистити його (всі пікселі = 0, тобто порожньо)
        clear();
    }

    // ────────────────────────────────────────────────────────────────────────
    // ДЕСТРУКТОР - Звільнення пам'яті
    // ────────────────────────────────────────────────────────────────────────
    
    /**
     * ~GameField() - ВИДАЛИТИ ПОЛЕ
     * 
     * Викликається автоматично коли обєкт видаляється
     * Звільняє динамічно виділену пам'ять (важливо!)
     * 
     * Якщо не видалити - буде "витік пам'яті" (memory leak)
     */
    ~GameField() {
        delete[] field;  // "[]" бо це масив, а не один обєкт
    }

    // ────────────────────────────────────────────────────────────────────────
    // ПУБЛІЧНІ МЕТОДИ (доступні всім)
    // ────────────────────────────────────────────────────────────────────────

    /**
     * clear() - ОЧИСТИТИ ВСЕ ПОЛЕ
     * 
     * Встановити всі пікселі на 0 (порожньо)
     * Використовується в init() і при рестарті гри
     */
    void clear() {
        // memset(куди, що, скільки байт)
        // Заповнити весь масив нулями
        memset(field, 0, height * sizeof(uint8_t));
    }

    /**
     * getRow(int y) - ОТРИМАТИ ОДИН РЯДОК
     * 
     * Повідомляє усі пікселі в рядку як один байт (0-255)
     * 
     * Приклад:
     *   uint8_t row = field.getRow(5);
     *   // row = 0b10101010 = 170 (десяткове)
     *   // піксель 0 = 0, піксель 1 = 1, піксель 2 = 0, і т.д.
     */
    uint8_t getRow(int y) const {
        // Перевірити границі (не вийти за межи поля)
        if (y < 0 || y >= height) return 0;
        return field[y];
    }

    /**
     * setPixel(int x, int y) - ВКЛЮЧИТИ ОДИН ПІКСЕЛЬ
     * 
     * Встановити піксель на позиції (x, y) в 1
     * Це означає "тут є блок"
     */
    void setPixel(int x, int y) {
        // Перевірити границі
        if (x < 0 || x >= width || y < 0 || y >= height) return;
        
        // bitSet(байт, номер біта) - встановити біт на 1
        // bitSet(field[y], x) = встановити біт номер x у рядку y
        bitSet(field[y], x);
    }

    /**
     * getPixel(int x, int y) - ПРОЧИТАТИ ОДИН ПІКСЕЛЬ
     * 
     * Повідомляє чи є піксель на позиції (x, y)
     * true = є (1), false = нема (0)
     */
    bool getPixel(int x, int y) const {
        // Перевірити границі
        if (x < 0 || x >= width || y < 0 || y >= height) return false;
        
        // bitRead(байт, номер біта) - прочитати біт
        // Повідомляє 0 або 1
        return bitRead(field[y], x) == 1;
    }

    /**
     * addBlock(const Block &block) - ДОДАТИ БЛОК НА ПОЛЕ
     * 
     * Коли блок приземляється, його піксели стають постійним частиною поля
     * 
     * Процес:
     * 1. Беремо Block obект (форма + позиція)
     * 2. Для кожного з 4 квадратів блока
     * 3. Обчислюємо його позицію на полі
     * 4. Встановлюємо цей піксель на 1
     */
    void addBlock(const Block &block) {
        // Цикл по 4 квадратам фігури
        for (int i = 0; i < 4; i++) {
            // Обчислити світову позицію квадрату
            // block.x + shape[i][0] = абсолютна X позиція
            // block.y + shape[i][1] = абсолютна Y позиція
            int xx = block.x + block.shape[i][0];
            int yy = block.y + block.shape[i][1];
            
            // Встановити цей піксель
            setPixel(xx, yy);
        }
    }

    /**
     * checkCollision(const Block &block, int bx, int by) - ПЕРЕВІРИТИ УДАР
     * 
     * Проверяет чи блок на позиції (bx, by) касается чего-то
     * 
     * Повідомляє:
     *   true = удар (блок не можна рухати туди)
     *   false = вільно (можна рухати)
     * 
     * Перевіряє:
     *   1. Чи блок вийде за межи поля (ліво, право, дно)?
     *   2. Чи блок упере у вже розміщені блоки?
     */
    bool checkCollision(const Block &block, int bx, int by) const {
        // Цикл по 4 квадратам блока
        for (int i = 0; i < 4; i++) {
            // Обчислити позицію квадрату при рухові
            int xx = bx + block.shape[i][0];
            int yy = by + block.shape[i][1];

            // ПЕРЕВІРКА 1: Чи вийде за межи (ліво, право, дно)?
            // (Top не перевіряємо - можна спавнити над екраном)
            if (xx < 0 || xx >= width || yy >= height) {
                return true;  // УДАР! Вийде за межи
            }

            // ПЕРЕВІРКА 2: Чи наткнеться на існуючі блоки?
            // (Перевіряємо тільки якщо Y >= 0, тобто на екрані)
            if (yy >= 0 && getPixel(xx, yy)) {
                return true;  // УДАР! Є вже блок на цій позиції
            }
        }
        
        // Всі перевірки пройдені - колізії нема!
        return false;
    }

    /**
     * clearFullRows() - ОЧИСТИТИ ПОВНІ РЯДКИ
     * 
     * Коли рядок повністю заповнений (як 0xFF = 11111111),
     * він очищується і показується як очки
     * 
     * Алгоритм:
     * 1. Пройти по всіх рядках
     * 2. Знайти рядки що = 0xFF (повністю заповнені)
     * 3. Видалити їх
     * 4. Зсунути все вниз
     * 5. Повідомити скільки рядків видалили
     */
    int clearFullRows() {
        int clearedCount = 0;  // Лічильник очищених рядків
        
        // Пройти по всіх рядках від низу до верху
        for (int y = 0; y < height; y++) {
            // Перевірити чи рядок заповнений
            // 0xFF = 0b11111111 = всі 8 пікселів зайняті
            if (field[y] == 0xFF) {
                clearedCount++;  // Обчисліти один рядок
                
                // Зсунути всі рядки вниз (скопіювати верхні вниз)
                for (int j = y; j > 0; j--) {
                    field[j] = field[j - 1];  // Скопіювати рядок вверх
                }
                
                // Верхня рядок стає порожною
                field[0] = 0;
                
                // Перевірити цей рядок ще раз (може там новий повний рядок)
                y--;
            }
        }
        
        return clearedCount;  // Повідомити кількість очищених рядків
    }

    // ────────────────────────────────────────────────────────────────────────
    // GETTER МЕТОДИ (отримувачі)
    // ────────────────────────────────────────────────────────────────────────
    
    /**
     * getWidth() - ОТРИМАТИ ШИРИНУ ПОЛЯ
     * const - не змінюємо стан, тільки читаємо
     */
    int getWidth() const { return width; }
    
    /**
     * getHeight() - ОТРИМАТИ ВИСОТУ ПОЛЯ
     * const - не змінюємо стан, тільки читаємо
     */
    int getHeight() const { return height; }
};
