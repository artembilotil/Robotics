#pragma once

/**
 * МОДУЛЬ: BlockController.h (КОНТРОЛЕР РУХУ)
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * ВІДПОВІДАЛЬНІСТЬ: Керування рухом та поворотом блока
 * 
 * Це як водій - він керує машиною (блоком):
 *   - Рухає ліворуч/праворуч
 *   - Обертає
 *   - Опускає вниз
 * 
 * Важливо: BlockController НЕ вирішує чи є колізія.
 * Він питає GameField: "Можна сюди рухнутися?"
 * Якщо "ні" - залишається на місці.
 * 
 * ПРИНЦИП SOLID:
 * - Single Responsibility: Тільки рух і поворот блока
 * - Dependency Inversion: Залежить від GameField (питає про колізії)
 * - Open/Closed: Легко додати новий тип поворотів
 */

#include "Block.h"
#include "GameField.h"
#include "ShapeData.h"

/**
 * КЛАС BLOCKCONTROLLER - КЕРУВАННЯ БЛОКОМ
 */
class BlockController {
private:
    // ────────────────────────────────────────────────────────────────────────
    // ПРИВАТНІ ЧЛЕНИ (видно тільки всередині)
    // ────────────────────────────────────────────────────────────────────────
    
    Block *currentBlock;              // ПОСИЛАННЯ на поточний блок (рухаємо цей)
    GameField *field;                 // ПОСИЛАННЯ на поле (перевіряємо колізії)
    IShapeProvider *shapeProvider;    // ПОСИЛАННЯ на постачальника форм (для поворотів)

public:
    // ────────────────────────────────────────────────────────────────────────
    // КОНСТРУКТОР
    // ────────────────────────────────────────────────────────────────────────
    
    /**
     * BlockController(Block *block, GameField *gameField, IShapeProvider *provider)
     * 
     * Отримує три посилання на інші компоненти:
     *   - block = блок який буде рухати
     *   - gameField = поле де відбувається рух
     *   - provider = пігахує форм для поворотів
     */
    BlockController(Block *block, GameField *gameField, IShapeProvider *provider)
        : currentBlock(block), field(gameField), shapeProvider(provider) {}

    // ────────────────────────────────────────────────────────────────────────
    // ПУБЛІЧНІ МЕТОДИ (рух блока)
    // ────────────────────────────────────────────────────────────────────────

    /**
     * moveLeft() - РУХНУТИ БЛОК ЛІВОРУЧ
     * 
     * Процес:
     * 1. Перевірити чи можна рухнути ліворуч (питаємо GameField)
     * 2. Якщо можна - зменшити X на 1
     * 3. Якщо нема місця - залишити на місці (нічого не робимо)
     */
    void moveLeft() {
        // checkCollision повідомляє: true = є удар, false = вільно
        if (!field->checkCollision(*currentBlock, currentBlock->x - 1, currentBlock->y)) {
            // Можна рухнути! Зменшуємо X на 1
            currentBlock->x -= 1;
        }
        // Якще є удар, просто нічого не робимо - блок залишається на місці
    }

    /**
     * moveRight() - РУХНУТИ БЛОК ПРАВОРУЧ
     * 
     * Те саме що moveLeft, але в іншу сторону
     */
    void moveRight() {
        // Перевіриці чи можна рухнути праворуч
        if (!field->checkCollision(*currentBlock, currentBlock->x + 1, currentBlock->y)) {
            // Можна рухнути! Збільшуємо X на 1
            currentBlock->x += 1;
        }
    }

    /**
     * rotate() - ОБЕРНУТИ БЛОК НА 90 ГРАДУСІВ
     * 
     * Складна операція з 4 кроками:
     * 1. Дізнатися скільки版本 повороту у цього блока (2, 4 для різних фігур)
     * 2. Обчислити наступний поворот ((текущий + 1) % максимум)
     * 3. Застосувати новий поворот (змінити форму)
     * 4. Якщо утворилась колізія - відкотити назад
     */
    void rotate() {
        // КРОК 1: Дізнатися скільки версій повороту у цього типу блока
        // (Фігура 'O' = 1 версія, фігура 'T' = 4 версії)
        int rotationCount = shapeProvider->getRotationCount(currentBlock->type);
        
        // КРОК 2: Обчислити наступний поворот
        // % (modulo) = залишок від ділення
        // (0 + 1) % 4 = 1, (1 + 1) % 4 = 2, (3 + 1) % 4 = 0 (цикл назад)
        int nextRotation = (currentBlock->rotation + 1) % rotationCount;

        // КРОК 3: Зберегти старий стан на випадок ошибки
        // Якщо поворот не вийде - можемо повернутися назад
        Block backup = *currentBlock;  // Копіюємо весь блок

        // КРОК 4: Застосувати новий поворот
        currentBlock->rotation = nextRotation;  // Встановити новий номер повороту
        currentBlock->shape = shapeProvider->getShape(currentBlock->type, nextRotation);  // Отримати нову форму

        // КРОК 5: Перевірити чи є колізія після повороту
        if (field->checkCollision(*currentBlock, currentBlock->x, currentBlock->y)) {
            // ❌ УПС! Удар! Не можна так обертатися (дісь у стіну)
            // Повертаємо старий стан
            *currentBlock = backup;
        }
        // ✅ Поворот успішний!
    }

    /**
     * dropOneStep() - ОПУСТИТИ БЛОК НА ОДИН РЯДОК ВНИЗ
     * 
     * Повідомляє:
     *   true = блок продовжує падати (успішно рухнувся)
     *   false = блок упав на дно (не можна рухнути ще вниз)
     * 
     * Це найважливіший метод - гра використовує його постійно!
     */
    bool dropOneStep() {
        // Перевірити чи можна опустити блок на 1 ряд вниз (Y + 1)
        if (field->checkCollision(*currentBlock, currentBlock->x, currentBlock->y + 1)) {
            // ❌ НЕ можна! Дно або інший блок
            return false;  // Сигналізуємо що блок "прилип"
        }
        
        // ✅ Можна рухнути! Збільшуємо Y на 1 (вниз)
        currentBlock->y += 1;
        return true;  // Сигналізуємо що блок продовжує падати
    }

    /**
     * getCurrentBlock() - ОТРИМАТИ ПОТОЧНИЙ БЛОК
     * 
     * Дозволяє іншим компонентам прочитати інформацію про блок
     * const - обіцяємо не змінювати блок через цей метод
     */
    const Block &getCurrentBlock() const {
        return *currentBlock;
    }

    /**
     * Встановити новий блок
     */
    void setBlock(const Block &newBlock) {
        *currentBlock = newBlock;
    }
};
